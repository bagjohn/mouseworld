
# coding: utf-8

# In[1]:

from mouseworld.mouseworld import Mouseworld
from mouseworld.predator import Predator
from mouseworld.mouse import Mouse
from mouseworld.food import Food

from mouseworld.my_viz import CanvasGrid
#from mesa.visualization.modules import CanvasGrid
from mesa.visualization.ModularVisualization import ModularServer

import math

def agent_portrayal(agent):
    if isinstance(agent,Predator):
        portrayal = {"Shape": "rect",
                     "Filled": "true",
                     "Layer": 0,
                     "Color": "Red",
                     "w": 1,
                     "h": 1}
        
    elif isinstance(agent,Food):
        portrayal = {"Shape": "circle",
                     "Filled": "true",
                     "Layer": 0,
                     "Color": "Green",
                     "r": 1}
        
    
        
    elif isinstance(agent,Mouse):
        portrayal = {"Shape": "circle",
                     "Filled": "true",
                     "Layer": 0,
                     "Color": "Blue",
                     "r": 1}
    return portrayal

width = 40
height = 40
viz_grid = CanvasGrid(agent_portrayal, width, height, 700, 700)
server = ModularServer(Mouseworld,
                       [viz_grid],
                       "Mouseworld_viz",
                       1, 5, 10, 0, width, height)
server.port = 8521 # The default
server.launch()


# In[2]:

get_ipython().run_cell_magic('writefile', 'mouseworld/my_viz.py', '\n# -*- coding: utf-8 -*-\n"""\nModular Canvas Rendering\n========================\nModule for visualizing model objects in grid cells.\n"""\nfrom collections import defaultdict\nfrom mesa.visualization.ModularVisualization import VisualizationElement\n\n\nclass CanvasGrid(VisualizationElement):\n    """ A CanvasGrid object uses a user-provided portrayal method to generate a\n    portrayal for each object. A portrayal is a JSON-ready dictionary which\n    tells the relevant JavaScript code (GridDraw.js) where to draw what shape.\n    The render method returns a dictionary, keyed on layers, with values as\n    lists of portrayals to draw. Portrayals themselves are generated by the\n    user-provided portrayal_method, which accepts an object as an input and\n    produces a portrayal of it.\n    A portrayal as a dictionary with the following structure:\n        "x", "y": Coordinates for the cell in which the object is placed.\n        "Shape": Can be either "circle", "rect" or "arrowHead"\n            For Circles:\n                "r": The radius, defined as a fraction of cell size. r=1 will\n                     fill the entire cell.\n            For Rectangles:\n                "w", "h": The width and height of the rectangle, which are in\n                          fractions of cell width and height.\n            For arrowHead:\n            "scale": Proportion scaling as a fraction of cell size.\n            "heading_x": represents x direction unit vector.\n            "heading_y": represents y direction unit vector.\n        "Color": The color to draw the shape in; needs to be a valid HTML\n                 color, e.g."Red" or "#AA08F8"\n        "Filled": either "true" or "false", and determines whether the shape is\n                  filled or not.\n        "Layer": Layer number of 0 or above; higher-numbered layers are drawn\n                 above lower-numbered layers.\n        "text": The text to be inscribed inside the Shape. Normally useful for\n                showing the unique_id of the agent.\n        "text_color": The color to draw the inscribed text. Should be given in\n                      conjunction of "text" property.\n    Attributes:\n        portrayal_method: Function which generates portrayals from objects, as\n                          described above.\n        grid_height, grid_width: Size of the grid to visualize, in cells.\n        canvas_height, canvas_width: Size, in pixels, of the grid visualization\n                                     to draw on the client.\n        template: "canvas_module.html" stores the module\'s HTML template.\n    """\n    package_includes = ["GridDraw.js", "CanvasModule.js"]\n    portrayal_method = None  # Portrayal function\n    canvas_width = 500\n    canvas_height = 500\n\n    def __init__(self, portrayal_method, grid_width, grid_height,\n                 canvas_width=500, canvas_height=500):\n        """ Instantiate a new CanvasGrid.\n        Args:\n            portrayal_method: function to convert each object on the grid to\n                              a portrayal, as described above.\n            grid_width, grid_height: Size of the grid, in cells.\n            canvas_height, canvas_width: Size of the canvas to draw in the\n                                         client, in pixels. (default: 500x500)\n        """\n        self.portrayal_method = portrayal_method\n        self.grid_width = grid_width\n        self.grid_height = grid_height\n        self.canvas_width = canvas_width\n        self.canvas_height = canvas_height\n\n        new_element = ("new CanvasModule({}, {}, {}, {})"\n            .format(self.canvas_width, self.canvas_height,\n                self.grid_width, self.grid_height))\n\n        self.js_code = "elements.push(" + new_element + ");"\n\n    def render(self, model):\n        grid_state = defaultdict(list)\n        grid = model.space._grid\n        for x in range(grid.width):\n            for y in range(grid.height):\n                cell_objects = grid.get_cell_list_contents([(x, y)])\n                for obj in cell_objects:\n                    portrayal = self.portrayal_method(obj)\n                    if portrayal:\n                        portrayal["x"] = x\n                        portrayal["y"] = y\n                        grid_state[portrayal["Layer"]].append(portrayal)\n\n        return grid_state')


# In[ ]:



